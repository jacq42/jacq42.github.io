---
layout: post
title:  Neuerungen in Java 8
tags: [ Java ]
author: jacq42
excerpt_separator: <!--more-->
color: rgb(0, 100,100)
---

Welche Neuerungen wurden mit Java 8 implementiert?

<!--more-->

[Stream API](#stream-api) | [Functional Interface](#functional-interfaces) | [Lambdas](#lambda-expressions) | [Interfacemethoden](#interfacemethoden) | [Methodenreferenzen](#methodenreferenzen) | [Optional](#optional)

## Stream API

Mit der Stream API `java.util.stream` gibt es die Möglichkeit, Methoden auf eine Sequenz von Elementen (Collection) anzuwenden.\
Beispiele:
* In einer Liste von Personen nach Namen mit dem Anfangsbuchstaben J suchen
* Alle Elemente einer Liste mit 10 multiplizieren (warum auch immer)
* Elemente einer Liste sortieren

Stream erstellen:\
`Stream.of("a", "b", "c")`\
`Arrays.stream(arr)` Wenn es bereits ein Array gibt.
`collection.stream()` Wenn es eine Collection ist.

Normalerweise werden Streams sequentiell bearbeitet. Dies kann man auch parallelisieren: `list.parallelStream()`

### Stream Operationen

Die Elemente des Streams werden nicht verändert, können aber in einer neuen Sequenz gespeichert werden.

Iterating: `list.stream().anyMatch(..)` Um Methoden auf jedem Element anzuwenden\
Filtering: `list.stream().filter(..)` Um bestimmte Elemente auszuwählen\
Mapping: `list.stream().map(..)` Um Elemente zu verändern oder die Daten zu verwenden\
Flatmapping: `list.stream().flatMap(..)` Wenn die Elemente selbst wieder Sequenzen sind (Liste von Listen) und man die inneren Elemente verwenden möchte\
Matching: `list.stream().anyMatch(..)` oder `list.stream().allMatch(..)` oder `list.stream().noneMatch(..)`
Reduction: `list.stream().reduce(..)` Um Elemente miteinander zu verbinden
Collecting: `list.stream().collect(..)` Um nach Anwendung von Filtering und Mapping die Element in einer neuen Sequenz zu sammeln

## Functional Interfaces

`@FunctionalInterface` Annotation markiert einen Typ als functional Interface. Das Interface kann lediglich abstrakte und default Methoden haben.

Wichtige im JDK definierte FunctionalInterfaces: zu finden in `java.util.function`
* `Supplier<T>`: Erzeugt Objekte
* `Function<T, R>`: Führt Operationen auf Objekten aus, die übergeben werden und gibt die neu entstandenen Objekte zurück
* `Predicate<T>`: Liefert true/false, wenn die definierte Methode auf die übergebenen Objekte angewendet wurde
* `Consumer<T>`: Führt Operationen auf Objekten aus, die übergeben werden

Die angegebenen Interfaces gibt es meist auch in der BiXXX Variante. Dann kann ein Parameter mehr übergeben werden. Z.B. können bei Functions dann 2 Inputwerte übergeben werden und es gibt weiterhin 1 Output.

## Lambda Expressions

Ist ein kurzer Codeblock, der Parameter nimmt und einen Wert zurückgibt. Sie sind ähnlich wie Methoden, haben jedoch keinen Namen und können innerhalb einer Methode implementiert werden.

Beispiel: `Stream.of(1, 2, 3, 4).forEach(n -> System.out::println)`

## Interfacemethoden

Statische Methoden:
```java
static String producer() {
    return "Lorem ipsum";
}
```
Zugriff innerhalb des Interface. Wenn Zugriff von außen, dann `Interface.producer()`


Default Methoden:
```java
default String blablub() {
    return "Some more text blablub";
}
```
Jede Klasse, die das Interface implementiert, kann diese Methode nutzen.\
Dies ist eine gute Möglichkeit, um nachträglich Methoden zu Interfaces hinzuzufügen. Ohne die default Methoden müsste jede Klasse, die das Interface implementiert die neue Methode implementieren oder es gibt einen Compileerror Jetzt kann man im Interface selbst eine default Methode erstellen und nach und nach diese in den Klassen überschreiben. 

## Methodenreferenzen

Kann in Lambda Expressions genutzt werden, damit der Code kürzer und damit lesbarer wird.

Es gibt verschiedene Arten:
* Class::methodeName `User::isMember`
* Instance::methodName  `user.isRealUser`
* Type::methodName `String::isEmpty`
* ClassName::new `User::new`

## Optional

Damit lassen sich NullPointerException (NPE) deutlich reduzieren. Ein Optional<T> ist ein Objekt, dass auch null sein kann.

Erstellen über `Optional.ofNullable(objekt)`

Hat diverse Methoden, um damit zu arbeiten. Z.B. kann wenn das Objekt null ist, ein anderes Objekt (Default) erstellt werden oder es kann eine Exception geworfen werden. Mit `Optional.isPresent()` kann auf Vorhandensein eines Wertes geprüft werden oder aber mit `Optional.ifPresent(..)` ein Consumer aufgerufen werden, der etwas mit dem Objekt macht.

## Weitere Informationen

* [Java Upgrade examples](https://github.com/johanjanssen/JavaUpgrades)
* Von Baeldung [Java 8 Features](https://www.baeldung.com/java-8-new-features)